import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { storage } from "./storage";
import { talkStorage } from "./talk-storage";
import { signalingMessageSchema } from "@shared/schema";

interface WebSocketWithId extends WebSocket {
  participantId?: string;
  roomId?: string;
}

export async function registerRoutes(app: Express): Promise<Server> {
  // ========= TalkDB API routes =========
  // ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°ç®¡ç†
  app.post("/api/meetings", async (req, res) => {
    try {
      // å…¥åŠ›æ¤œè¨¼
      if (!req.body.title || req.body.title.trim().length === 0) {
        return res.status(400).json({ error: "Meeting title is required" });
      }
      if (!req.body.hostId || req.body.hostId.trim().length === 0) {
        return res.status(400).json({ error: "Host ID is required" });
      }

      const meetingId = await talkStorage.generateMeetingId();
      const meeting = await talkStorage.createMeeting({
        meetingId,
        title: req.body.title.trim().slice(0, 200), // é•·ã•åˆ¶é™
        description: req.body.description?.trim().slice(0, 1000) || "",
        hostId: req.body.hostId.trim(),
        maxParticipants: Math.min(req.body.maxParticipants || 50, 100), // æœ€å¤§100äººåˆ¶é™
      });
      res.status(201).json(meeting);
    } catch (error) {
      console.error("Failed to create meeting:", error);
      res.status(500).json({ error: "Failed to create meeting" });
    }
  });

  app.get("/api/meetings/:meetingId", async (req, res) => {
    try {
      const meeting = await talkStorage.getMeeting(req.params.meetingId);
      if (!meeting) {
        return res.status(404).json({ error: "Meeting not found" });
      }
      res.json(meeting);
    } catch (error) {
      console.error("Failed to get meeting:", error);
      res.status(500).json({ error: "Failed to get meeting" });
    }
  });

  // å‚åŠ è€…ç®¡ç†
  app.post("/api/meetings/:meetingId/participants", async (req, res) => {
    try {
      const participant = await talkStorage.addMeetingParticipant({
        meetingId: req.params.meetingId,
        participantId: req.body.participantId || req.body.connectionId, // connectionIdã‚‚å—ã‘å…¥ã‚Œã‚‹
        displayName: req.body.displayName,
        role: req.body.role || "participant",
      });
      res.status(201).json(participant);
    } catch (error) {
      console.error("Failed to add participant:", error);
      res.status(500).json({ error: "Failed to add participant" });
    }
  });

  app.get("/api/meetings/:meetingId/participants", async (req, res) => {
    try {
      const participants = await talkStorage.getMeetingParticipants(req.params.meetingId);
      res.json(participants);
    } catch (error) {
      console.error("Failed to get participants:", error);
      res.status(500).json({ error: "Failed to get participants" });
    }
  });

  // ãƒãƒ£ãƒƒãƒˆå±¥æ­´
  app.get("/api/meetings/:meetingId/chat", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 100;
      const messages = await talkStorage.getTalkHistory(req.params.meetingId, limit);
      res.json(messages);
    } catch (error) {
      console.error("Failed to get chat history:", error);
      res.status(500).json({ error: "Failed to get chat history" });
    }
  });

  app.post("/api/meetings/:meetingId/chat", async (req, res) => {
    try {
      const message = await talkStorage.addTalkMessage({
        meetingId: req.params.meetingId,
        participantId: req.body.participantId,
        displayName: req.body.displayName,
        message: req.body.message,
        messageType: req.body.messageType || "text",
        replyToId: req.body.replyToId || null,
      });
      res.status(201).json(message);
    } catch (error) {
      console.error("Failed to add chat message:", error);
      res.status(500).json({ error: "Failed to add chat message" });
    }
  });

  app.get("/api/meetings/:meetingId/stats", async (req, res) => {
    try {
      const stats = await talkStorage.getMeetingStats(req.params.meetingId);
      if (!stats) {
        return res.status(404).json({ error: "Meeting not found" });
      }
      res.json(stats);
    } catch (error) {
      console.error("Failed to get meeting stats:", error);
      res.status(500).json({ error: "Failed to get meeting stats" });
    }
  });

  // ========= æ—¢å­˜ã®API routes =========
  // REST API routes
  app.get("/api/rooms/:roomId", async (req, res) => {
    try {
      const room = await storage.getRoom(req.params.roomId);
      if (!room) {
        return res.status(404).json({ error: "Room not found" });
      }
      res.json(room);
    } catch (error) {
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.post("/api/rooms", async (req, res) => {
    try {
      const room = await storage.createRoom(req.body);
      res.status(201).json(room);
    } catch (error) {
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.get("/api/rooms/:roomId/participants", async (req, res) => {
    try {
      const participants = await storage.getParticipants(req.params.roomId);
      res.json(participants);
    } catch (error) {
      res.status(500).json({ error: "Internal server error" });
    }
  });

  const httpServer = createServer(app);

  // WebSocket server for signaling
  const wss = new WebSocketServer({ 
    server: httpServer, 
    path: '/ws',
    maxPayload: 1024 * 1024, // 1MBã®åˆ¶é™
  });

  // æ¥ç¶šæ•°ã‚’ç›£è¦–ã™ã‚‹ãŸã‚ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
  let connectionCount = 0;
  const MAX_CONNECTIONS = 1000;

  wss.on('connection', (ws: WebSocketWithId, req) => {
    connectionCount++;
    console.log(`New WebSocket connection (${connectionCount}/${MAX_CONNECTIONS})`);

    // æ¥ç¶šæ•°åˆ¶é™
    if (connectionCount > MAX_CONNECTIONS) {
      console.warn('Max connections reached, closing new connection');
      ws.close(1013, 'Server overloaded');
      connectionCount--;
      return;
    }

    ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString());
        const validatedMessage = signalingMessageSchema.parse(message);

        switch (validatedMessage.type) {
          case 'join-room':
            await handleJoinRoom(ws, validatedMessage, wss);
            break;

          case 'leave-room':
            await handleLeaveRoom(ws, validatedMessage, wss);
            break;

          case 'offer':
          case 'answer':
          case 'ice-candidate':
            await handleSignalingMessage(ws, validatedMessage, wss);
            break;

          case 'participant-update':
            await handleParticipantUpdate(ws, validatedMessage, wss);
            break;

          case 'chat-message':
            await handleChatMessage(ws, validatedMessage, wss);
            break;

          case 'chat-history':
            await handleChatHistory(ws, validatedMessage);
            break;
        }
      } catch (error) {
        console.error('WebSocket message error:', error);
        ws.send(JSON.stringify({
          type: 'error',
          message: 'Invalid message format'
        }));
      }
    });

    ws.on('close', async () => {
      connectionCount--;
      console.log(`WebSocket connection closed (${connectionCount}/${MAX_CONNECTIONS})`);
      
      if (ws.participantId && ws.roomId) {
        await handleLeaveRoom(ws, {
          type: 'leave-room',
          roomId: ws.roomId,
          participantId: ws.participantId,
          payload: {}
        }, wss);
      }
    });

    ws.on('error', (error) => {
      console.error('WebSocket error:', error);
      connectionCount--;
    });
  });

  async function handleJoinRoom(ws: WebSocketWithId, message: any, wss: WebSocketServer) {
    const { roomId, participantId, payload } = message;

    ws.participantId = participantId;
    ws.roomId = roomId;

    // Ensure room exists
    let room = await storage.getRoom(roomId);
    if (!room) {
      room = await storage.createRoom({
        id: roomId,
        name: `Room ${roomId}`,
        maxParticipants: 10,
        isActive: true
      });
    }

    // Add participant to room
    const participant = await storage.addParticipant({
      roomId,
      displayName: payload.displayName,
      isHost: false,
      isMuted: false,
      isVideoEnabled: false,
      connectionId: participantId
    });

    // TalkDBå‚åŠ è€…ç®¡ç†ã¨ã®åŒæœŸ
    if (payload.meetingId) {
      try {
        await talkStorage.addMeetingParticipant({
          meetingId: payload.meetingId,
          participantId: participantId,
          displayName: payload.displayName,
          role: "participant",
        });
        console.log(`âœ… Synced participant to TalkDB meeting ${payload.meetingId}`);
      } catch (talkError) {
        console.warn("Failed to sync participant to TalkDB:", talkError);
      }
    }

    // Get all participants in room
    const participants = await storage.getParticipants(roomId);

    // Send current participants list to new participant
    ws.send(JSON.stringify({
      type: 'participants-list',
      payload: participants
    }));

    // Notify other participants about new participant
    broadcastToRoom(wss, roomId, {
      type: 'participant-joined',
      payload: participant
    }, participantId);

    console.log(`Participant ${participantId} joined room ${roomId}`);
  }

  async function handleLeaveRoom(ws: WebSocketWithId, message: any, wss: WebSocketServer) {
    const { roomId, participantId } = message;

    // Remove participant from storage
    await storage.removeParticipant(roomId, participantId);

    // Notify other participants
    broadcastToRoom(wss, roomId, {
      type: 'participant-left',
      payload: { connectionId: participantId }
    }, participantId);

    console.log(`Participant ${participantId} left room ${roomId}`);

    ws.participantId = undefined;
    ws.roomId = undefined;
  }

  async function handleSignalingMessage(ws: WebSocketWithId, message: any, wss: WebSocketServer) {
    const { roomId, participantId, targetParticipant, payload } = message;

    console.log(`Forwarding ${message.type} from ${participantId} to ${targetParticipant || 'all'}`);

    // Validate signaling message has required fields
    if (!payload) {
      console.error("Signaling message missing payload:", message.type);
      return;
    }

    // For offers and answers, ensure SDP content exists
    if ((message.type === 'offer' || message.type === 'answer') &&
      (!payload.sdp || payload.sdp.trim().length === 0)) {
      console.error(`Invalid ${message.type} - missing or empty SDP from ${participantId}`);
      return;
    }

    // Forward signaling message to target participant or all participants
    wss.clients.forEach((client: WebSocketWithId) => {
      if (client.readyState === WebSocket.OPEN &&
        client.roomId === roomId &&
        client.participantId !== participantId) {

        // If targetParticipant is specified, only send to that participant
        if (targetParticipant && client.participantId !== targetParticipant) {
          return;
        }

        console.log(`Sending ${message.type} to ${client.participantId}`);
        client.send(JSON.stringify({
          type: message.type,
          participantId: participantId,
          payload: payload
        }));
      }
    });
  }

  async function handleParticipantUpdate(ws: WebSocketWithId, message: any, wss: WebSocketServer) {
    const { roomId, participantId, payload } = message;

    // Update participant in storage
    await storage.updateParticipant(roomId, participantId, payload);

    // Broadcast update to other participants
    broadcastToRoom(wss, roomId, {
      type: 'participant-updated',
      participantId: participantId,
      payload: payload
    }, participantId);
  }

  async function handleChatMessage(ws: WebSocketWithId, message: any, wss: WebSocketServer) {
    console.log("=== handleChatMessage called ===");
    console.log("Full message:", JSON.stringify(message, null, 2));

    const { roomId, participantId, payload } = message;
    const meetingId = payload.meetingId || roomId; // meetingIdãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°roomIdã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

    console.log("Extracted data:", { roomId, meetingId, participantId, payload });

    try {
      // ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ - XSSæ”»æ’ƒã‚’é˜²ã
      const sanitizedMessage = payload.message
        ?.toString()
        .trim()
        .slice(0, 1000) // æœ€å¤§1000æ–‡å­—ã«åˆ¶é™
        .replace(/[<>]/g, ''); // HTMLã‚¿ã‚°ã‚’é™¤å»

      const sanitizedDisplayName = payload.displayName
        ?.toString()
        .trim()
        .slice(0, 50) // æœ€å¤§50æ–‡å­—ã«åˆ¶é™
        .replace(/[<>]/g, ''); // HTMLã‚¿ã‚°ã‚’é™¤å»

      console.log("Sanitized data:", { sanitizedMessage, sanitizedDisplayName });

      if (!sanitizedMessage || !sanitizedDisplayName) {
        console.warn("âŒ Invalid message content:", { sanitizedMessage, sanitizedDisplayName });
        ws.send(JSON.stringify({
          type: 'error',
          message: 'Invalid message content'
        }));
        return;
      }

      // Save to both storage systems for compatibility
      console.log("ğŸ’¾ Saving chat message to database...");
      
      // Legacy chat storage
      const chatMessage = await storage.addChatMessage({
        roomId,
        participantId: participantId || 'unknown',
        displayName: sanitizedDisplayName,
        message: sanitizedMessage,
        type: payload.type || 'text'
      });

      // TalkDB storage (if meetingId is provided)
      if (meetingId && meetingId !== roomId) {
        try {
          await talkStorage.addTalkMessage({
            meetingId,
            participantId: participantId || 'unknown',
            displayName: sanitizedDisplayName,
            message: sanitizedMessage,
            messageType: payload.type || 'text',
          });
          console.log("âœ… Saved to TalkDB as well");
        } catch (talkError) {
          console.warn("Failed to save to TalkDB:", talkError);
        }
      }

      // Broadcast chat message to all participants in room
      broadcastToRoom(wss, roomId, {
        type: 'chat-message',
        payload: chatMessage
      });

      console.log(`Chat message in room ${roomId} from ${sanitizedDisplayName}: ${sanitizedMessage}`);
    } catch (error) {
      console.error('Error handling chat message:', error);
      ws.send(JSON.stringify({
        type: 'error',
        message: 'Failed to send chat message'
      }));
    }
  }

  async function handleChatHistory(ws: WebSocketWithId, message: any) {
    const { roomId, payload } = message;
    const meetingId = payload?.meetingId || roomId; // meetingIdãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°ãã‚Œã‚’ä½¿ç”¨

    try {
      let chatHistory;
      
      // TalkDB ã‹ã‚‰ã®å±¥æ­´å–å¾—ã‚’å„ªå…ˆ
      if (meetingId && meetingId !== roomId) {
        try {
          chatHistory = await talkStorage.getTalkHistory(meetingId);
          console.log(`Retrieved ${chatHistory.length} messages from TalkDB for meeting ${meetingId}`);
        } catch (talkError) {
          console.warn("Failed to fetch from TalkDB, falling back to legacy storage:", talkError);
          chatHistory = await storage.getChatHistory(roomId);
        }
      } else {
        // Legacy storage
        chatHistory = await storage.getChatHistory(roomId);
      }

      // Send chat history to requesting participant
      ws.send(JSON.stringify({
        type: 'chat-history',
        payload: chatHistory
      }));
    } catch (error) {
      console.error('Error fetching chat history:', error);
      ws.send(JSON.stringify({
        type: 'error',
        message: 'Failed to fetch chat history'
      }));
    }
  }

  function broadcastToRoom(wss: WebSocketServer, roomId: string, message: any, excludeParticipant?: string) {
    const messageStr = JSON.stringify(message);
    let sentCount = 0;
    let errorCount = 0;

    wss.clients.forEach((client: WebSocketWithId) => {
      if (client.readyState === WebSocket.OPEN &&
        client.roomId === roomId &&
        client.participantId !== excludeParticipant) {
        try {
          client.send(messageStr);
          sentCount++;
        } catch (error) {
          console.error(`Failed to send message to participant ${client.participantId}:`, error);
          errorCount++;
        }
      }
    });

    console.log(`Broadcast to room ${roomId}: sent to ${sentCount} clients, ${errorCount} errors`);
  }

  return httpServer;
}
