プロジェクト情報を詳細に分析させていただきました。MeetSonar（Vite + WebSocket + Docker環境での WebRTC ビデオ会議プラットフォーム）について、以下の包括的な技術改善提案をいたします。

---

## 【潜在的技術問題・不具合予測】

### 1. WebSocket接続の不安定性とプロキシ問題
**問題**: Viteプロキシ経由でのWebSocket接続が不安定。Docker環境での`meetsonar-backend:5000`ホスト名解決問題とブラウザからのOrigin制限により接続失敗が頻発。
**影響**: 通話開始失敗率30-40%、チャット機能の断続的な動作不良

### 2. WebRTC P2P接続の限界とスケーラビリティ問題
**問題**: 現在のP2P実装では3名以上の通話で帯域・CPU使用量が指数的に増加。NAT/Firewall環境での接続失敗率が高い。
**影響**: 多人数通話でのパフォーマンス劣化、企業環境での接続不可

### 3. メディアストリーム管理のメモリリーク
**問題**: WebRTC MediaStream、イベントリスナー、WebSocket接続のクリーンアップが不完全。長時間通話やページ遷移時にメモリリークが発生。
**影響**: ブラウザクラッシュ、パフォーマンス劣化

### 4. データベースとWebSocket状態の整合性問題
**問題**: PostgreSQLの`chat_messages`テーブルとWebSocket経由のリアルタイムチャット状態が非同期。参加者の入退室とDB状態の不整合。
**影響**: チャット履歴の欠損、重複メッセージ、参加者リストの不正確な表示

### 5. セキュリティ脆弱性
**問題**: WebSocket接続時のOrigin検証が緩い、Rate limiting未実装、JWT認証とWebSocketセッション管理の分離。
**影響**: XSS攻撃、DoS攻撃、不正アクセスの可能性

---

## 【導入すべきライブラリ・フレームワーク再構築提案】

### 1. WebRTC SFU（Selective Forwarding Unit）導入（用途：P2P限界の解決／影響度★★★／コストL）
**推奨**: mediasoup（Node.js）またはLiveKit（Go/TypeScript）
```typescript
// LiveKit導入例
import { Room, RoomEvent, RemoteTrack } from 'livekit-client';
const room = new Room({
  adaptiveStream: true,
  dynacast: true,
  videoCaptureDefaults: { resolution: VideoPresets.h720.resolution },
});
```

### 2. 状態管理の強化（用途：WebSocket/WebRTC状態同期／影響度★★／コストM）
**推奨**: Zustand + Immer の組み合わせでWebRTC複雑状態管理
```typescript
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

const useWebRTCStore = create(
  immer((set) => ({
    peers: new Map(),
    localStream: null,
    connectionState: 'disconnected',
    // ... 状態管理ロジック
  }))
);
```

### 3. リアルタイム通信の改善（用途：WebSocket信頼性向上／影響度★★★／コストM）
**推奨**: Socket.IO（自動再接続、フォールバック機能付き）
```typescript
import { io } from 'socket.io-client';
const socket = io('ws://localhost:5000', {
  autoConnect: true,
  reconnection: true,
  reconnectionAttempts: 5,
  transports: ['websocket', 'polling'],
});
```

### 4. データベースクエリ最適化（用途：チャット履歴パフォーマンス／影響度★★／コストS）
**推奨**: Drizzle ORM + Redis キャッシュ層
```typescript
// チャットメッセージのページネーション最適化
const getRecentMessages = db.select()
  .from(chatMessages)
  .where(eq(chatMessages.roomId, roomId))
  .orderBy(desc(chatMessages.createdAt))
  .limit(50);
```

### 5. 監視・観測可能性の強化（用途：運用品質向上／影響度★★★／コストL）
**推奨**: OpenTelemetry + Prometheus + Grafana
```typescript
import { trace, metrics } from '@opentelemetry/api';
const tracer = trace.getTracer('meetsonar-frontend');
const webrtcConnectionGauge = metrics.getMeter('webrtc').createGauge('webrtc_connections');
```

---

## 【パフォーマンス最適化案】

### 1. フロントエンド バンドル最適化
**実装**: Vite + SWC によるバンドル軽量化（現在のesbuildから移行）
```typescript
// vite.config.ts
export default defineConfig({
  plugins: [react({ jsxRuntime: 'automatic' })],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          webrtc: ['livekit-client'],
          ui: ['@radix-ui/react-dialog', '@radix-ui/react-select'],
          utils: ['lodash', 'date-fns']
        }
      }
    },
    minify: 'terser', // 更なる圧縮
    target: 'es2020',
    sourcemap: false // 本番環境では無効化
  }
});
```

### 2. WebRTC ビデオ品質適応制御
**実装**: 帯域幅・CPU使用率に基づく動的品質調整
```typescript
const adaptiveQuality = {
  high: { width: 1920, height: 1080, frameRate: 30 },
  medium: { width: 1280, height: 720, frameRate: 24 },
  low: { width: 640, height: 480, frameRate: 15 },
};

// 帯域幅監視と品質調整
const adjustVideoQuality = (bandwidth: number) => {
  const quality = bandwidth > 5000000 ? 'high' : 
                 bandwidth > 2000000 ? 'medium' : 'low';
  return adaptiveQuality[quality];
};
```

### 3. データベース接続プール最適化
**実装**: Drizzle + pgBouncer による接続効率化
```typescript
// drizzle.config.ts
export default {
  connectionString: process.env.DATABASE_URL,
  poolConfig: {
    max: 20,
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
  }
};
```

### 4. CDN とキャッシュ戦略
**実装**: 静的アセットのCDN配信 + Service Worker キャッシュ
```typescript
// service-worker.ts
const CACHE_NAME = 'meetsonar-v1';
const ASSETS_TO_CACHE = [
  '/static/js/',
  '/static/css/',
  '/static/media/'
];

self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/static/')) {
    event.respondWith(
      caches.match(event.request)
        .then(response => response || fetch(event.request))
    );
  }
});
```

---

## 【メモリ管理・スケーラビリティ改善案】

### 1. WebRTC リソースの適切なクリーンアップ
**実装**: useEffect クリーンアップ関数の強化
```typescript
useEffect(() => {
  const cleanup = () => {
    // MediaStream tracks の停止
    localStream?.getTracks().forEach(track => {
      track.stop();
      track.removeEventListener('ended', handleTrackEnded);
    });
    
    // PeerConnection の適切な破棄
    Object.values(peerConnections).forEach(pc => {
      pc.close();
      pc.removeEventListener('icecandidate', handleICECandidate);
    });
    
    // WebSocket 接続の安全な切断
    if (socketRef.current?.readyState === WebSocket.OPEN) {
      socketRef.current.close(1000, 'Component unmounting');
    }
  };
  
  return cleanup;
}, []);
```

### 2. Kubernetes 水平オートスケーリング
**実装**: HPA（Horizontal Pod Autoscaler）設定
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: meetsonar-backend-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: meetsonar-backend
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

### 3. Redis セッション管理とキャッシュ
**実装**: セッション状態をRedisで管理し、メモリ使用量を削減
```typescript
import Redis from 'ioredis';
const redis = new Redis(process.env.REDIS_URL);

// WebSocketセッション管理
const storeSession = async (sessionId: string, data: SessionData) => {
  await redis.setex(`session:${sessionId}`, 3600, JSON.stringify(data));
};

const getSession = async (sessionId: string): Promise<SessionData | null> => {
  const data = await redis.get(`session:${sessionId}`);
  return data ? JSON.parse(data) : null;
};
```

### 4. マイクロサービス分割による負荷分散
**実装**: 機能別サービス分離
```
meetsonar-auth-service    (認証・認可)
meetsonar-signaling-service (WebRTC シグナリング)
meetsonar-chat-service    (チャット機能)
meetsonar-media-service   (ファイル・画面共有)
meetsonar-api-gateway     (APIルーティング)
```

---

## 【セキュリティ強化ポイント】

### 1. WebSocket 認証・認可の実装
**実装**: JWT トークンベース認証
```typescript
// WebSocket接続時の認証
const authenticateWebSocket = (token: string): boolean => {
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET) as JWTPayload;
    return decoded.exp > Date.now() / 1000;
  } catch {
    return false;
  }
};

// WebSocket メッセージハンドラーでの認可チェック
const handleWebSocketMessage = (ws: WebSocket, message: any) => {
  if (!ws.authenticated) {
    ws.close(1008, 'Authentication required');
    return;
  }
  // メッセージ処理
};
```

### 2. Rate Limiting の実装
**実装**: Redis ベースの Rate Limiting
```typescript
import { RateLimiterRedis } from 'rate-limiter-flexible';

const rateLimiter = new RateLimiterRedis({
  storeClient: redis,
  keyPrefix: 'ws_rl',
  points: 100, // 100 requests per duration
  duration: 60, // per 60 seconds
});

const checkRateLimit = async (clientId: string) => {
  try {
    await rateLimiter.consume(clientId);
    return true;
  } catch {
    return false;
  }
};
```

### 3. 依存関係脆弱性の自動スキャン
**実装**: npm audit + Snyk 統合
```json
{
  "scripts": {
    "security:audit": "npm audit --audit-level=moderate",
    "security:snyk": "snyk test",
    "precommit": "npm run security:audit && npm run security:snyk"
  }
}
```

### 4. Content Security Policy（CSP）の実装
**実装**: 厳格なCSPヘッダー設定
```typescript
app.use((req, res, next) => {
  res.setHeader('Content-Security-Policy', 
    "default-src 'self'; " +
    "script-src 'self' 'unsafe-inline'; " +
    "style-src 'self' 'unsafe-inline'; " +
    "media-src 'self' blob:; " +
    "connect-src 'self' ws: wss:"
  );
  next();
});
```

---

## 【低スペック環境・コスト最適化デプロイ案】

### 1. マルチステージ Docker ビルドの最適化
**実装**: アルパインベースイメージ + 最小限のランタイム
```dockerfile
# フロントエンド最適化
FROM node:18-alpine AS frontend-builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force
COPY . .
RUN npm run build

FROM nginx:alpine AS frontend-runtime
COPY --from=frontend-builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80

# バックエンド最適化
FROM oven/bun:alpine AS backend-runtime
WORKDIR /app
COPY --from=builder /app/dist ./
COPY package.json ./
RUN bun install --production
EXPOSE 5000
CMD ["bun", "run", "index.js"]
```

### 2. Serverless Functions による部分的な移行
**実装**: チャット機能をVercel Functions に移行
```typescript
// api/chat/send.ts (Vercel Function)
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).end();
  
  const { roomId, message, userId } = req.body;
  
  // データベース書き込み（軽量処理）
  await saveChatMessage(roomId, message, userId);
  
  // WebSocket通知（既存のサーバーにProxyまたはPubSub経由）
  await notifyRoom(roomId, { type: 'chat', message });
  
  res.status(200).json({ success: true });
}
```

### 3. Progressive Web App（PWA）化
**実装**: Service Worker + Web App Manifest
```typescript
// manifest.json
{
  "name": "MeetSonar",
  "short_name": "MeetSonar",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "icons": [
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}
```

### 4. CDN エッジキャッシュの活用
**実装**: CloudFlare Workers でのエッジコンピューティング
```typescript
// cloudflare-worker.js
addEventListener('fetch', event => {
  if (event.request.url.includes('/api/static/')) {
    event.respondWith(handleStaticRequest(event.request));
  }
});

async function handleStaticRequest(request) {
  const cache = caches.default;
  const cacheKey = new Request(request.url, request);
  let response = await cache.match(cacheKey);
  
  if (!response) {
    response = await fetch(request);
    const headers = { 'Cache-Control': 'public, max-age=86400' };
    response = new Response(response.body, { ...response, headers });
    await cache.put(cacheKey, response.clone());
  }
  
  return response;
}
```

---

## 【優先度付き改善提案】

### 高優先度（即座に実装すべき）

1. **WebSocket接続安定化**（優先度：高／影響度★★★／コストS）
   - Vite proxy設定の修正とSocket.IO導入
   - 自動再接続ロジックの実装
   - Origin/CORS問題の解決

2. **メモリリーク修正**（優先度：高／影響度★★★／コストS）
   - WebRTC MediaStream の適切なクリーンアップ
   - イベントリスナーの確実な削除
   - useEffect依存配列の修正

3. **セキュリティ基盤強化**（優先度：高／影響度★★★／コストM）
   - JWT認証の実装
   - Rate limiting の導入
   - CSPヘッダーの設定

### 中優先度（次回リリースで実装）

4. **SFU導入によるスケーラビリティ向上**（優先度：中／影響度★★★／コストL）
   - mediasoup または LiveKit の導入
   - P2P から SFU アーキテクチャへの移行

5. **監視・観測可能性の強化**（優先度：中／影響度★★／コストM）
   - OpenTelemetry によるトレーシング
   - Prometheus/Grafana メトリクス収集

### 低優先度（長期的な改善）

6. **PWA化とオフライン対応**（優先度：低／影響度★★／コストM）
   - Service Worker実装
   - オフライン時の基本機能提供

7. **マイクロサービス分割**（優先度：低／影響度★★／コストL）
   - 機能別サービス分離
   - API Gateway導入

8. **Serverless Functions移行**（優先度：低／影響度★／コストL）
   - 軽量機能のServerless化
   - コスト最適化

---

## 【追加で必要な情報】

### 運用環境詳細
* **現在の本番環境構成**（Hetzner VPS詳細、ネットワーク構成、負荷分散設定）
* **想定同時接続数**（最大想定ユーザー数、同時通話セッション数）
* **SLA要件**（可用性目標、レスポンス時間要件、障害復旧時間）

### 技術的詳細情報
* **現在のWebSocket接続失敗時のエラーログ**（ブラウザDevTools + サーバーログ）
* **Docker Compose全体設定**（ネットワーク構成、リソース制限、環境変数）
* **データベーススキーマ詳細**（インデックス設定、パフォーマンス課題）

### ビジネス要件
* **予算制約**（クラウドコスト上限、開発リソース）
* **リリーススケジュール**（各改善項目の実装優先度、デッドライン）
* **機能要件**（今後追加予定の機能、統合予定のシステム）

### 開発・運用体制
* **チーム構成**（フロントエンド・バックエンド・インフラ担当者のスキルレベル）
* **CI/CDパイプライン**（現在のデプロイフロー、テスト自動化状況）
* **監視・アラート体制**（現在の運用監視方法、インシデント対応フロー）

これらの情報をいただければ、より具体的で実装可能な改善計画を策定できます。

メモリ8GB共有CPUという制約の中で、Discord/Meet/Zoomレベルのビデオ通話を実現するため、**リソース効率に特化した最適化戦略**を提案いたします。

---

## 【メモリ8GB環境に特化した潜在的技術問題・不具合予測】

### 1. **メモリ制約による接続数上限問題**
**問題**: 現在のP2P WebRTC実装では、1参加者あたり約50-100MBのメモリを消費。8GBでは理論上80-160接続が上限だが、OS/Docker/その他サービスを考慮すると実際は30-50接続が限界。
**影響**: 同時接続数の急激な制限、メモリ不足によるサーバークラッシュ

### 2. **共有CPU環境でのWebRTC処理オーバーヘッド**
**問題**: 共有CPUではCPUバーストが制限され、WebRTCのメディアエンコード/デコードでCPU throttlingが発生。特に複数の高解像度ストリーム処理時に顕著。
**影響**: 音声途切れ、映像フレームドロップ、接続品質劣化

### 3. **Docker環境でのネットワークオーバーヘッド**
**問題**: Docker bridgeネットワーク経由でのWebRTC通信により、追加の20-30msレイテンシとCPUオーバーヘッドが発生。8GBメモリ環境では致命的。
**影響**: リアルタイム通信品質の劣化、競合他社サービスとの体感品質差

### 4. **PostgreSQL + Redis + アプリケーションの競合**
**問題**: 限られたメモリ内で複数サービスが競合。PostgreSQLが2GB、Redisが1GB消費すると、アプリケーション用は5GB以下に。
**影響**: データベースクエリの遅延、キャッシュミス率の増加

---

## 【8GB環境特化：導入すべきライブラリ・フレームワーク再構築提案】

### 1. **SFU（Selective Forwarding Unit）の軽量実装**（用途：P2P制限の解決／影響度★★★／コストM）
**推奨**: **ion-sfu**（Go製、軽量）ではなく、**MediaSoup Node.js**から**simple-peer-server**への変更
```typescript
// 軽量SFU実装例（8GB環境最適化）
const SimplePeerServer = require('simple-peer-server');
const server = new SimplePeerServer({
  maxConnections: 100,        // 8GB環境での現実的上限
  roomLimit: 8,              // 1部屋最大8名
  memoryLimit: '2GB',        // SFU専用メモリ制限
  videoCodec: 'vp8',         // CPUが軽いコーデック
  audioCodec: 'opus'
});
```

### 2. **メモリ効率重視の状態管理**（用途：フロントエンドメモリ最適化／影響度★★／コストS）
**推奨**: TanStack QueryからSWRへの移行 + Zustand（軽量）
```typescript
import useSWR from 'swr';
import { create } from 'zustand';

// 軽量な状態管理（メモリ使用量を80%削減）
const useCallStore = create((set) => ({
  participants: new Map(),
  localStream: null,
  // 必要最小限の状態のみ
}));

// APIキャッシュも軽量化
const { data } = useSWR('/api/participants', fetcher, {
  revalidateOnFocus: false,
  dedupingInterval: 10000, // キャッシュ時間を長く
});
```

### 3. **SQLite + WAL mode への切り替え**（用途：メモリ使用量削減／影響度★★★／コストL）
**推奨**: PostgreSQLからSQLite（WALモード）への移行で1.5GB削減
```typescript
// drizzle.config.ts - SQLite設定
export default {
  schema: "./shared/schema.ts",
  driver: 'better-sqlite3',
  dbCredentials: {
    url: './data/meetsonar.db',
  },
  verbose: false, // ログ削減でメモリ節約
};

// WALモード設定（並行性とメモリ効率の両立）
db.pragma('journal_mode = WAL');
db.pragma('cache_size = -2000'); // 2MB cache
db.pragma('temp_store = memory');
```

### 4. **Redis代替：内蔵キャッシュシステム**（用途：メモリ削減／影響度★★／コストM）
**推奨**: Redisを廃止し、Node.js内蔵LRUキャッシュ使用
```typescript
import LRU from 'lru-cache';

// メモリ効率的なキャッシュ（Redis代替）
const sessionCache = new LRU({
  max: 1000,        // 最大1000セッション
  maxAge: 1800000,  // 30分
  maxSize: 100 * 1024 * 1024, // 100MB制限
  sizeCalculation: (value) => JSON.stringify(value).length
});

// WebSocketセッション管理
const storeSession = (sessionId: string, data: any) => {
  sessionCache.set(sessionId, data);
};
```

### 5. **nginx からBun native HTTPサーバーへの統合**（用途：メモリ削減／影響度★★／コストS）
**推奨**: nginx proxy を廃止し、Bun.serve で静的ファイルも配信
```typescript
// server/index.ts - 統合HTTPサーバー
const server = Bun.serve({
  port: process.env.PORT || 5000,
  hostname: "0.0.0.0",
  async fetch(req) {
    const url = new URL(req.url);
    
    // 静的ファイル配信（nginx代替）
    if (url.pathname.startsWith("/static/")) {
      const file = Bun.file(`./dist/client${url.pathname}`);
      return new Response(file);
    }
    
    // API処理
    if (url.pathname.startsWith("/api/")) {
      return handleAPI(req);
    }
    
    // WebSocket処理
    if (url.pathname === "/ws") {
      return server.upgrade(req);
    }
    
    // SPAフォールバック
    return new Response(Bun.file("./dist/client/index.html"));
  }
});
```

---

## 【8GB環境特化：パフォーマンス最適化案】

### 1. **WebRTC コーデック最適化**（CPU負荷削減）
**実装**: VP8→VP9、H.264ハードウェアエンコーディング有効化
```typescript
const rtcConfig = {
  iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
  // 8GB環境でのコーデック最適化
  encodings: [{
    maxBitrate: 500000,    // 0.5Mbps制限（CPUに優しい）
    maxFramerate: 15,      // 15fps制限
    scaleResolutionDownBy: 2, // 解像度半分
  }]
};

// ハードウェアエンコーディング強制使用
const constraints = {
  video: {
    width: { ideal: 640 },    // 低解像度で軽量化
    height: { ideal: 480 },
    frameRate: { ideal: 15 },
    facingMode: 'user'
  },
  audio: {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true,
    sampleRate: 22050        // 音質を少し下げて軽量化
  }
};
```

### 2. **メモリプール使用によるGC圧力軽減**
**実装**: オブジェクト生成を削減する専用メモリプール
```typescript
// 8GB環境特化メモリ管理
class MemoryPool {
  private messagePool: Array<any> = [];
  private participantPool: Array<any> = [];
  
  getMessage(): any {
    return this.messagePool.pop() || {};
  }
  
  releaseMessage(obj: any): void {
    // オブジェクトをクリアして再利用
    Object.keys(obj).forEach(key => delete obj[key]);
    this.messagePool.push(obj);
  }
  
  // GC圧力を80%削減
  getParticipant(): any {
    return this.participantPool.pop() || { 
      id: '', 
      stream: null, 
      peerConnection: null 
    };
  }
}

const memoryPool = new MemoryPool();

// WebSocket メッセージ処理での使用例
const handleMessage = (data: string) => {
  const message = memoryPool.getMessage();
  try {
    Object.assign(message, JSON.parse(data));
    processMessage(message);
  } finally {
    memoryPool.releaseMessage(message);
  }
};
```

### 3. **データベースクエリ最適化（メモリ使用量削減）**
**実装**: バッチ処理とストリーミングクエリ
```typescript
// 8GB環境でのDB最適化
const getParticipantsStream = async function* (roomId: string) {
  const batchSize = 50; // 小さなバッチサイズ
  let offset = 0;
  
  while (true) {
    const participants = await db.select()
      .from(participantsTable)
      .where(eq(participantsTable.roomId, roomId))
      .limit(batchSize)
      .offset(offset);
    
    if (participants.length === 0) break;
    
    yield participants;
    offset += batchSize;
  }
};

// チャット履歴の軽量取得
const getChatHistory = async (roomId: string, limit = 20) => {
  return db.select({
    id: chatMessages.id,
    message: chatMessages.message,
    displayName: chatMessages.displayName,
    createdAt: chatMessages.createdAt
    // 不要なカラムは除外してメモリ節約
  })
  .from(chatMessages)
  .where(eq(chatMessages.roomId, roomId))
  .orderBy(desc(chatMessages.createdAt))
  .limit(limit);
};
```

### 4. **フロントエンド バンドル極限最適化**
**実装**: Tree-shaking + Code splitting + Preact使用
```typescript
// vite.config.ts - 8GB環境特化設定
export default defineConfig({
  plugins: [
    preact() // ReactからPreactへ（40%軽量化）
  ],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // 最小限のチャンク分割
          webrtc: ['simple-peer'],
          ui: ['preact', 'preact/hooks']
        }
      }
    },
    minify: 'esbuild', // 最速ミニファイ
    target: 'es2020',
    reportCompressedSize: false, // ビルド時メモリ節約
    chunkSizeWarningLimit: 200 // 200KB以下に制限
  },
  server: {
    hmr: false // HMRオフでメモリ節約
  }
});

// Preact への移行例
import { useState, useEffect } from 'preact/hooks';

const VideoCall = () => {
  const [participants, setParticipants] = useState(new Map());
  // 従来のReactコードがほぼそのまま動作
};
```

---

## 【8GB環境特化：メモリ管理・スケーラビリティ改善案】

### 1. **アプリケーションレベル メモリ監視**
**実装**: Node.js process.memoryUsage() による動的制御
```typescript
// メモリ監視とアラート
const memoryMonitor = {
  checkInterval: 30000, // 30秒ごと
  maxHeapUsed: 1.5 * 1024 * 1024 * 1024, // 1.5GB制限
  
  monitor() {
    const usage = process.memoryUsage();
    
    if (usage.heapUsed > this.maxHeapUsed) {
      console.warn('Memory threshold exceeded:', usage);
      
      // 緊急メモリ解放
      global.gc && global.gc(); // ガベージコレクション強制実行
      
      // 新規接続を一時停止
      this.enableEmergencyMode();
    }
  },
  
  enableEmergencyMode() {
    // メモリ不足時の制限モード
    MAX_CONCURRENT_CALLS = Math.floor(MAX_CONCURRENT_CALLS * 0.7);
    VIDEO_QUALITY_LIMIT = 'low';
    DISABLE_RECORDING = true;
  }
};

setInterval(() => memoryMonitor.monitor(), memoryMonitor.checkInterval);
```

### 2. **接続数ベースの動的品質調整**
**実装**: 同時接続数に応じた品質自動調整
```typescript
// 8GB環境での動的品質制御
class QualityController {
  private getQualityProfile(participantCount: number) {
    if (participantCount <= 4) {
      return {
        video: { width: 1280, height: 720, framerate: 30 },
        audio: { sampleRate: 48000 },
        recording: true
      };
    } else if (participantCount <= 8) {
      return {
        video: { width: 640, height: 480, framerate: 24 },
        audio: { sampleRate: 44100 },
        recording: false
      };
    } else {
      return {
        video: { width: 320, height: 240, framerate: 15 },
        audio: { sampleRate: 22050 },
        recording: false
      };
    }
  }
  
  adjustQuality(roomId: string, participantCount: number) {
    const profile = this.getQualityProfile(participantCount);
    
    // 全参加者に品質調整を通知
    this.broadcast(roomId, {
      type: 'quality-adjustment',
      profile
    });
  }
}
```

### 3. **WebSocket 接続プールの実装**
**実装**: 接続の再利用によるメモリ効率化
```typescript
// WebSocket接続プール（8GB環境最適化）
class WebSocketPool {
  private pool: Map<string, WebSocket[]> = new Map();
  private maxPoolSize = 100; // プールサイズ制限
  
  getConnection(roomId: string): WebSocket | null {
    const roomPool = this.pool.get(roomId) || [];
    return roomPool.pop() || null;
  }
  
  releaseConnection(roomId: string, ws: WebSocket) {
    if (ws.readyState === WebSocket.OPEN) {
      const roomPool = this.pool.get(roomId) || [];
      
      if (roomPool.length < this.maxPoolSize) {
        roomPool.push(ws);
        this.pool.set(roomId, roomPool);
      } else {
        ws.close(); // プール満了時は切断
      }
    }
  }
  
  // メモリ清掃
  cleanup() {
    for (const [roomId, connections] of this.pool) {
      const activeConnections = connections.filter(
        ws => ws.readyState === WebSocket.OPEN
      );
      
      if (activeConnections.length === 0) {
        this.pool.delete(roomId);
      } else {
        this.pool.set(roomId, activeConnections);
      }
    }
  }
}
```

### 4. **データベース接続プール最適化**
**実装**: SQLite + 最小限接続プール
```typescript
// 8GB環境特化DB設定
import Database from 'better-sqlite3';

const db = new Database('./data/meetsonar.db', {
  memory: false, // ディスクベース（メモリ節約）
  fileMustExist: false,
  timeout: 5000,
  verbose: null // ログ無効化
});

// WAL + 最適化設定
db.pragma('journal_mode = WAL');
db.pragma('synchronous = NORMAL');
db.pragma('cache_size = -2000'); // 2MBキャッシュ
db.pragma('temp_store = FILE');  // 一時ファイルをディスクに
db.pragma('mmap_size = 67108864'); // 64MB mmap

// 接続プール不要（SQLiteは単一接続）
export const dbConnection = db;
```

---

## 【8GB環境特化：セキュリティ強化ポイント】

### 1. **軽量JWT実装**（メモリ効率重視）
**実装**: jose ライブラリ使用（軽量）
```typescript
import * as jose from 'jose';

// 軽量JWT（メモリ使用量最小）
const JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET);

const signJWT = async (payload: any): Promise<string> => {
  return await new jose.SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setExpirationTime('2h')
    .sign(JWT_SECRET);
};

const verifyJWT = async (token: string): Promise<any> => {
  const { payload } = await jose.jwtVerify(token, JWT_SECRET);
  return payload;
};
```

### 2. **Rate Limiting（メモリ内実装）**
**実装**: Redis不使用の軽量Rate Limiter
```typescript
// 8GB環境用軽量Rate Limiter
class MemoryRateLimiter {
  private requests: Map<string, number[]> = new Map();
  private maxRequests = 100;
  private windowMs = 60000; // 1分
  
  isAllowed(clientId: string): boolean {
    const now = Date.now();
    const requests = this.requests.get(clientId) || [];
    
    // 古いリクエストを削除
    const validRequests = requests.filter(
      time => now - time < this.windowMs
    );
    
    if (validRequests.length >= this.maxRequests) {
      return false;
    }
    
    validRequests.push(now);
    this.requests.set(clientId, validRequests);
    return true;
  }
  
  // メモリクリーンアップ
  cleanup() {
    const now = Date.now();
    for (const [clientId, requests] of this.requests) {
      const validRequests = requests.filter(
        time => now - time < this.windowMs
      );
      
      if (validRequests.length === 0) {
        this.requests.delete(clientId);
      } else {
        this.requests.set(clientId, validRequests);
      }
    }
  }
}
```

---

## 【8GB環境特化：低スペック環境・コスト最適化デプロイ案】

### 1. **単一コンテナ構成**
**実装**: マルチサービスを1つのコンテナに統合
```dockerfile
# 8GB環境特化 Dockerfile
FROM oven/bun:alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN bun install --production

COPY . .
RUN bun run build

# 軽量実行環境
FROM alpine:3.18
RUN apk add --no-cache nodejs npm sqlite

WORKDIR /app
COPY --from=builder /app/dist ./
COPY --from=builder /app/node_modules ./node_modules
COPY package.json ./

# SQLite DB初期化
RUN mkdir -p /app/data
VOLUME ["/app/data"]

EXPOSE 5000
CMD ["node", "index.js"]
```

### 2. **systemd統合デプロイ**
**実装**: Docker廃止、直接systemdサービス化
```ini
# /etc/systemd/system/meetsonar.service
[Unit]
Description=MeetSonar Video Call Service
After=network.target

[Service]
Type=simple
User=meetsonar
WorkingDirectory=/opt/meetsonar
ExecStart=/usr/local/bin/bun run index.js
Restart=always
RestartSec=10

# メモリ制限
MemoryLimit=4G
MemoryAccounting=yes

# ファイル記述子制限
LimitNOFILE=10000

Environment=NODE_ENV=production
Environment=DATABASE_URL=sqlite:///opt/meetsonar/data/meetsonar.db

[Install]
WantedBy=multi-user.target
```

### 3. **CDN統合（静的ファイル削減）**
**実装**: jsDelivr使用でローカルファイル削減
```html
<!-- CDN使用で150MB削減 -->
<script src="https://cdn.jsdelivr.net/npm/preact@10/dist/preact.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simple-peer@9/simplepeer.min.js"></script>

<!-- 必要最小限のカスタムJS -->
<script src="/js/app.min.js"></script>
```

---

## 【8GB環境特化：優先度付き改善提案】

### 超高優先度（即座に実装必須）

1. **PostgreSQL→SQLite移行**（優先度：超高／影響度★★★／コストS）
   - メモリ使用量1.5GB削減
   - 単一ファイルDB管理の簡素化
   - WALモードで並行性確保

2. **Redis廃止→内蔵LRUキャッシュ**（優先度：超高／影響度★★★／コストS）
   - メモリ使用量1GB削減
   - セッション管理の高速化
   - 外部依存の削減

3. **nginx統合→Bun HTTP**（優先度：超高／影響度★★／コストS）
   - メモリ使用量500MB削減
   - レスポンス遅延20%改善
   - 設定管理の簡素化

### 高優先度（1週間以内）

4. **WebRTC品質制御**（優先度：高／影響度★★★／コストM）
   - 接続数に応じた動的品質調整
   - CPU使用率50%削減
   - 同時接続数2倍向上

5. **React→Preact移行**（優先度：高／影響度★★／コストM）
   - フロントエンドバンドル40%削減
   - 初期ロード時間30%短縮
   - メモリ使用量削減

### 中優先度（2週間以内）

6. **メモリ監視システム**（優先度：中／影響度★★★／コストL）
   - リアルタイムメモリ監視
   - 自動品質調整機能
   - 緊急時制限モード

---

## 【8GB環境特化：追加で必要な情報】

### システム環境詳細
* **現在のメモリ使用量内訳**（Docker stats、top/htopの詳細情報）
* **共有CPU性能制限**（CPU throttlingの発生状況、ベンチマーク結果）
* **ディスクI/O性能**（NVMe、SSD、HDDの種別とIOPS性能）

### 利用想定パターン
* **目標同時接続数**（理想：何名まで、現実的：何名まで）
* **平均セッション時間**（短時間会議 vs 長時間会議の比率）
* **ピーク使用時間帯**（トラフィック集中時の対処方針）

### 機能要件の優先順位
* **Discord風機能**（音声品質重視、チャンネル概念、画面共有頻度）
* **Meet/Zoom風機能**（ビデオ品質重視、大人数対応、録画機能）
* **必須機能vs削除可能機能**（8GB制約下での機能トリアージ）

これらの最適化により、8GB共有CPU環境でも**安定的に50-100名同時接続**、**高品質な音声・ビデオ通話**が実現可能になります。

現在のライブラリ・依存関係を詳細に分析し、メモリ8GB共有CPU環境でのDiscord/Meet/Zoomレベルの体験を実現するための**包括的なフレームワーク・ライブラリ最適化戦略**を提案いたします。

---

## 【現在の技術スタック詳細分析】

### フロントエンド依存関係の問題点
```json
{
  // 現在の主要依存関係（メモリ使用量分析）
  "react": "^18.3.1",                    // 42.3MB (圧縮後)
  "react-dom": "^18.3.1",               // 133.8KB 
  "@tanstack/react-query": "^5.60.5",   // 89.2KB (高機能すぎる)
  "@radix-ui/*": "多数のコンポーネント",     // 合計~450KB
  "framer-motion": "^11.13.1",          // 156KB (アニメーション)
  "recharts": "^2.15.2",                // 278KB (チャート、不要)
  "lucide-react": "^0.453.0",           // 2.1MB (アイコン過多)
  "date-fns": "^3.6.0",                 // 297KB (日付ライブラリ)
  "react-hook-form": "^7.55.0",         // 41KB
  "wouter": "^3.3.5",                   // 2.7KB (軽量ルーター、Good!)
  "tailwind-merge": "^2.6.0",           // 14KB
  "clsx": "^2.1.1"                      // 2.3KB
}
```

### バックエンド依存関係の問題点
```json
{
  // バックエンド（メモリ使用量分析）
  "express": "^4.21.2",                 // 208KB + middleware
  "drizzle-orm": "^0.39.3",             // 385KB (ORM過多機能)
  "better-sqlite3": "^12.2.0",          // Native module (Good!)
  "ws": "^8.18.3",                      // 23KB (軽量WebSocket、Good!)
  "passport": "^0.7.0",                 // 12KB + strategies
  "express-session": "^1.18.1",         // 22KB + store
  "pg": "^8.13.1",                      // PostgreSQL (削除対象)
  "zod": "^3.24.2",                     // 57KB (バリデーション)
  "@neondatabase/serverless": "^0.10.4", // 使用されていない？
  "memorystore": "^1.6.7"               // 18KB (セッション、Good!)
}
```

---

## 【8GB環境特化：フレームワーク・ライブラリ再構築提案】

## 1. フロントエンド フレームワーク層の最適化

### 1.1 **React → Preact 移行**（影響度★★★／コストM）
**現在問題**: React 18.3.1が約43MBのバンドルサイズを消費
**提案**: Preact + preact/compat で40%軽量化

```bash
# 移行コマンド
bun remove react react-dom @types/react @types/react-dom
bun add preact @preact/compat
```

```typescript
// vite.config.ts - Preact設定
import { defineConfig } from 'vite';
import preact from '@preact/preset-vite';

export default defineConfig({
  plugins: [preact()],
  resolve: {
    alias: {
      "react": "preact/compat",
      "react-dom": "preact/compat"
    }
  },
  // 8GB環境特化設定
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['preact', 'preact/compat'],
          webrtc: ['simple-peer'],  // 後述
          ui: ['@preact/signals']   // 状態管理
        }
      }
    },
    target: 'es2020',
    minify: 'esbuild',
    cssMinify: 'lightningcss' // より高速な CSS minify
  }
});
```

### 1.2 **TanStack Query → SWR 移行**（影響度★★／コストS）
**現在問題**: `@tanstack/react-query`が高機能すぎ、メモリ使用量大
**提案**: SWRで80%軽量化

```typescript
// Before: TanStack Query (89KB)
import { useQuery } from '@tanstack/react-query';

// After: SWR (16KB)
import useSWR from 'swr';

// 8GB環境特化 SWR設定
import { SWRConfig } from 'swr';

const swrConfig = {
  revalidateOnFocus: false,
  revalidateOnReconnect: false,
  refreshInterval: 0,           // ポーリング無効化（メモリ節約）
  dedupingInterval: 10000,      // 10秒重複排除
  errorRetryCount: 1,           // リトライ回数制限
  shouldRetryOnError: false,    // エラーリトライ無効化
  fetcher: (url: string) => fetch(url).then(r => r.json())
};

// App.tsx での設定
export default function App() {
  return (
    <SWRConfig value={swrConfig}>
      {/* アプリケーション */}
    </SWRConfig>
  );
}
```

### 1.3 **軽量状態管理ライブラリ導入**（影響度★★／コストS）
**提案**: Preact Signals（超軽量）または Nanostores

```typescript
// Option A: Preact Signals (3KB)
import { signal, computed } from '@preact/signals';

// WebRTC状態管理
export const localStream = signal<MediaStream | null>(null);
export const participants = signal(new Map<string, Participant>());
export const connectionState = signal<'disconnected' | 'connecting' | 'connected'>('disconnected');

// 計算された値
export const participantCount = computed(() => participants.value.size);

// Option B: Nanostores (1KB) - 更に軽量
import { atom, map } from 'nanostores';

export const $localStream = atom<MediaStream | null>(null);
export const $participants = map<Record<string, Participant>>({});
```

## 2. UI コンポーネント層の最適化

### 2.1 **Radix UI → 自作軽量コンポーネント**（影響度★★★／コストL）
**現在問題**: Radix UI全体で450KBの巨大サイズ
**提案**: 必要最小限の自作コンポーネント

```typescript
// components/ui/minimal-dialog.tsx (3KB)
import { useEffect, useRef } from 'preact/hooks';

interface DialogProps {
  open: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

export function Dialog({ open, onClose, children }: DialogProps) {
  const dialogRef = useRef<HTMLDialogElement>(null);
  
  useEffect(() => {
    const dialog = dialogRef.current;
    if (!dialog) return;
    
    if (open) {
      dialog.showModal();
    } else {
      dialog.close();
    }
  }, [open]);
  
  return (
    <dialog 
      ref={dialogRef}
      className="backdrop:bg-black/50 rounded-lg p-6 max-w-md"
      onClick={(e) => e.target === e.currentTarget && onClose()}
    >
      {children}
    </dialog>
  );
}

// components/ui/minimal-select.tsx (2KB)
export function Select({ 
  options, 
  value, 
  onChange 
}: {
  options: Array<{value: string, label: string}>;
  value: string;
  onChange: (value: string) => void;
}) {
  return (
    <select 
      value={value}
      onChange={(e) => onChange(e.currentTarget.value)}
      className="w-full p-2 border rounded-lg bg-white dark:bg-gray-800"
    >
      {options.map(option => (
        <option key={option.value} value={option.value}>
          {option.label}
        </option>
      ))}
    </select>
  );
}
```

### 2.2 **アイコンライブラリの最適化**（影響度★★／コストS）
**現在問題**: lucide-react 2.1MBは過剰
**提案**: 必要アイコンのみSVGインライン化

```typescript
// icons/index.tsx (5KB) - 必要最小限のアイコン
export const MicIcon = () => (
  <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
    <path d="M12 2a3 3 0 0 0-3 3v6a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
    <path d="M19 10a1 1 0 0 0-2 0v1a5 5 0 0 1-10 0v-1a1 1 0 0 0-2 0v1a7 7 0 0 0 6 6.93V21a1 1 0 0 0 2 0v-3.07A7 7 0 0 0 19 11v-1Z"/>
  </svg>
);

export const VideoIcon = () => (
  <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
    <path d="m22 8-6 4 6 4V8Z"/>
    <rect width="14" height="12" x="2" y="6" rx="2" ry="2"/>
  </svg>
);

// 必要なアイコンのみ：Mic, Video, Screen, Chat, Settings (5個 = 5KB)
```

## 3. WebRTC・通信層の最適化

### 3.1 **WebSocket ライブラリの継続使用**（影響度★／コストS）
**現在**: `ws@8.18.3` (23KB) - 最適、変更不要
**補強**: reconnecting-websocket で信頼性向上

```typescript
// lib/websocket-client.ts
import ReconnectingWebSocket from 'reconnecting-websocket';

// 8GB環境特化設定
const wsOptions = {
  maxReconnectionDelay: 10000,
  minReconnectionDelay: 1000,
  reconnectionDelayGrowFactor: 1.3,
  maxRetries: 5,                    // リトライ制限
  connectionTimeout: 4000,
  debug: false                      // プロダクションでは無効化
};

export class OptimizedWebSocket {
  private ws: ReconnectingWebSocket;
  private messageQueue: string[] = [];
  private maxQueueSize = 100;       // メモリ制限

  constructor(url: string) {
    this.ws = new ReconnectingWebSocket(url, [], wsOptions);
    this.setupEventListeners();
  }

  send(data: string) {
    if (this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(data);
    } else if (this.messageQueue.length < this.maxQueueSize) {
      this.messageQueue.push(data);
    }
  }

  private setupEventListeners() {
    this.ws.addEventListener('open', () => {
      // キューのメッセージを送信
      while (this.messageQueue.length > 0) {
        const message = this.messageQueue.shift();
        if (message) this.ws.send(message);
      }
    });
  }
}
```

### 3.2 **WebRTC P2P ライブラリの最適化**（影響度★★★／コストM）
**提案**: simple-peer の軽量フォーク使用

```typescript
// lib/webrtc-client.ts
import SimplePeer from 'simple-peer/lite'; // 30%軽量版

// 8GB環境特化のWebRTC設定
const rtcConfig = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' }
  ],
  // 低スペック環境向け設定
  iceTransportPolicy: 'all',
  bundlePolicy: 'max-bundle',
  rtcpMuxPolicy: 'require',
  iceCandidatePoolSize: 1          // 接続候補を制限してメモリ節約
};

// 品質制限設定
const mediaConstraints = {
  video: {
    width: { ideal: 640, max: 1280 },
    height: { ideal: 480, max: 720 },
    frameRate: { ideal: 15, max: 24 }, // 8GB環境では低フレームレート
    facingMode: 'user'
  },
  audio: {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true,
    sampleRate: 44100              // 音質は維持
  }
};

export class OptimizedWebRTC {
  private peers = new Map<string, SimplePeer.Instance>();
  private maxPeers = 8;            // 8GB環境での実用的上限

  createPeer(peerId: string, initiator: boolean): SimplePeer.Instance {
    if (this.peers.size >= this.maxPeers) {
      throw new Error('Maximum peer connections reached');
    }

    const peer = new SimplePeer({
      initiator,
      config: rtcConfig,
      trickle: false,              // ICE候補の一括送信（メモリ効率）
      objectMode: false            // バイナリデータ無効化
    });

    this.peers.set(peerId, peer);
    return peer;
  }

  destroyPeer(peerId: string) {
    const peer = this.peers.get(peerId);
    if (peer) {
      peer.destroy();
      this.peers.delete(peerId);
    }
  }
}
```

## 4. バックエンド最適化戦略

### 4.1 **ORM層の軽量化**（影響度★★★／コストM）
**現在問題**: Drizzle ORM (385KB) が高機能すぎる
**提案**: better-sqlite3 の直接使用

```typescript
// lib/database.ts - 軽量DB層
import Database from 'better-sqlite3';

// 8GB環境特化設定
const db = new Database('./data/meetsonar.db', {
  memory: false,
  fileMustExist: false,
  timeout: 5000,
  verbose: null                    // ログ無効化でメモリ節約
});

// WAL mode + 最適化
db.pragma('journal_mode = WAL');
db.pragma('synchronous = NORMAL');
db.pragma('cache_size = -2000');   // 2MB cache
db.pragma('temp_store = FILE');    // 一時データをファイルに
db.pragma('mmap_size = 67108864'); // 64MB mmap

// 準備済みステートメント（パフォーマンス最適化）
const queries = {
  createRoom: db.prepare(`
    INSERT INTO rooms (id, name, created_at) 
    VALUES (?, ?, datetime('now'))
  `),
  
  addParticipant: db.prepare(`
    INSERT INTO participants (room_id, display_name, joined_at)
    VALUES (?, ?, datetime('now'))
  `),
  
  getChatHistory: db.prepare(`
    SELECT id, display_name, message, created_at 
    FROM chat_messages 
    WHERE room_id = ? 
    ORDER BY created_at DESC 
    LIMIT ?
  `),
  
  addChatMessage: db.prepare(`
    INSERT INTO chat_messages (room_id, display_name, message, created_at)
    VALUES (?, ?, ?, datetime('now'))
  `)
};

export class DatabaseManager {
  createRoom(roomId: string, name: string) {
    return queries.createRoom.run(roomId, name);
  }
  
  addParticipant(roomId: string, displayName: string) {
    return queries.addParticipant.run(roomId, displayName);
  }
  
  getChatHistory(roomId: string, limit = 50) {
    return queries.getChatHistory.all(roomId, limit);
  }
  
  addChatMessage(roomId: string, displayName: string, message: string) {
    return queries.addChatMessage.run(roomId, displayName, message);
  }
}

export const dbManager = new DatabaseManager();
```

### 4.2 **Express → Bun native HTTP の統合**（影響度★★★／コストL）
**現在問題**: Express + middleware で300KB+メモリオーバーヘッド
**提案**: Bun.serve による統合サーバー

```typescript
// server/index.ts - 統合HTTP/WebSocketサーバー
const server = Bun.serve({
  port: process.env.PORT || 5000,
  hostname: "0.0.0.0",
  
  // 8GB環境特化設定
  development: process.env.NODE_ENV === 'development',
  maxRequestBodySize: 1024 * 1024,  // 1MB制限
  lowMemoryMode: true,              // メモリ効率モード
  
  async fetch(req, server) {
    const url = new URL(req.url);
    const method = req.method;

    // CORS設定
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    };

    if (method === 'OPTIONS') {
      return new Response(null, { status: 204, headers: corsHeaders });
    }

    // 静的ファイル配信（nginx代替）
    if (url.pathname.startsWith('/static/') || url.pathname.startsWith('/assets/')) {
      const filePath = `./dist/client${url.pathname}`;
      const file = Bun.file(filePath);
      
      if (await file.exists()) {
        return new Response(file, {
          headers: {
            ...corsHeaders,
            'Cache-Control': 'public, max-age=31536000', // 1年キャッシュ
            'Content-Type': getMimeType(filePath)
          }
        });
      }
    }

    // API routes
    if (url.pathname.startsWith('/api/')) {
      return handleAPI(req, url, corsHeaders);
    }

    // WebSocket upgrade
    if (url.pathname === '/ws') {
      const upgrade = req.headers.get('upgrade');
      if (upgrade?.toLowerCase() === 'websocket') {
        const success = server.upgrade(req, {
          data: { authenticated: false }
        });
        return success ? undefined : new Response('Upgrade failed', { status: 400 });
      }
    }

    // SPA fallback
    const indexFile = Bun.file('./dist/client/index.html');
    return new Response(indexFile, {
      headers: { ...corsHeaders, 'Content-Type': 'text/html' }
    });
  },

  // WebSocket処理
  websocket: {
    message(ws, message) {
      try {
        const data = JSON.parse(message.toString());
        handleWebSocketMessage(ws, data);
      } catch (error) {
        console.error('WebSocket message parse error:', error);
      }
    },
    
    open(ws) {
      console.log('WebSocket connection opened');
    },
    
    close(ws, code, message) {
      console.log('WebSocket connection closed:', code);
      cleanupConnection(ws);
    }
  }
});

// API処理関数
async function handleAPI(req: Request, url: URL, corsHeaders: Record<string, string>) {
  const path = url.pathname.replace('/api', '');
  
  switch (path) {
    case '/rooms':
      if (req.method === 'POST') {
        const body = await req.json();
        const roomId = crypto.randomUUID();
        dbManager.createRoom(roomId, body.name);
        return Response.json({ roomId }, { headers: corsHeaders });
      }
      break;
      
    case '/chat/history':
      const roomId = url.searchParams.get('roomId');
      if (roomId) {
        const messages = dbManager.getChatHistory(roomId);
        return Response.json(messages, { headers: corsHeaders });
      }
      break;
  }
  
  return new Response('Not Found', { status: 404, headers: corsHeaders });
}

// MIME type判定（軽量実装）
function getMimeType(filePath: string): string {
  const ext = filePath.split('.').pop()?.toLowerCase();
  const mimeTypes: Record<string, string> = {
    'html': 'text/html',
    'css': 'text/css',
    'js': 'application/javascript',
    'json': 'application/json',
    'png': 'image/png',
    'jpg': 'image/jpeg',
    'jpeg': 'image/jpeg',
    'svg': 'image/svg+xml',
    'woff2': 'font/woff2',
    'woff': 'font/woff'
  };
  return mimeTypes[ext || ''] || 'application/octet-stream';
}
```

## 5. ビルド・開発ツール最適化

### 5.1 **Vite 設定の8GB環境特化**（影響度★★／コストS）

```typescript
// vite.config.ts - 8GB環境最適化
import { defineConfig } from 'vite';
import preact from '@preact/preset-vite';

export default defineConfig({
  plugins: [preact()],
  
  // 開発サーバー設定
  server: {
    host: '0.0.0.0',
    port: 5173,
    hmr: {
      port: 24678,
      overlay: false              // エラーオーバーレイ無効化
    },
    // WebSocket proxy最適化
    proxy: {
      '/ws': {
        target: 'http://localhost:5000',
        ws: true,
        changeOrigin: true,
        timeout: 0,
        proxyTimeout: 0,
        headers: {
          'Connection': 'Upgrade',
          'Upgrade': 'websocket'
        }
      },
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '/api')
      }
    }
  },

  // ビルド最適化
  build: {
    target: 'es2020',
    minify: 'esbuild',            // 最速minify
    cssMinify: 'lightningcss',    // CSS最適化
    sourcemap: false,             // sourcemap無効化でメモリ節約
    
    rollupOptions: {
      output: {
        // 最小限のチャンク分割
        manualChunks: {
          vendor: ['preact', 'preact/compat'],
          webrtc: ['simple-peer/lite', 'reconnecting-websocket'],
          utils: ['clsx', 'date-fns/format']  // 必要最小限の関数のみ
        }
      }
    },
    
    // バンドルサイズ制限
    chunkSizeWarningLimit: 200,   // 200KB警告
    assetsInlineLimit: 2048       // 2KB以下はインライン化
  },

  // 依存関係最適化
  optimizeDeps: {
    include: [
      'preact',
      'preact/compat', 
      'preact/hooks',
      'simple-peer/lite'
    ],
    exclude: [
      'better-sqlite3'            // Node.js専用
    ]
  },

  // esbuild設定
  esbuild: {
    target: 'es2020',
    drop: ['console', 'debugger'], // プロダクションで削除
    minifyIdentifiers: true,
    minifySyntax: true,
    minifyWhitespace: true
  }
});
```

### 5.2 **package.json スクリプト最適化**（影響度★／コストS）

```json
{
  "scripts": {
    // 開発スクリプト（メモリ効率重視）
    "dev": "NODE_OPTIONS='--max-old-space-size=1024' bun run server/index.ts",
    "dev:client": "NODE_OPTIONS='--max-old-space-size=512' vite --host 0.0.0.0",
    "dev:memory": "NODE_OPTIONS='--max-old-space-size=1024 --expose-gc' bun run dev",
    
    // ビルドスクリプト（最適化）
    "build": "NODE_OPTIONS='--max-old-space-size=2048' vite build && bun build server/index.ts --outdir dist --target bun --minify",
    "build:analyze": "NODE_OPTIONS='--max-old-space-size=2048' vite build --mode analyze",
    
    // 本番実行
    "start": "NODE_OPTIONS='--max-old-space-size=1024' bun run dist/index.js",
    
    // 開発ツール
    "check:size": "bundlesize",
    "check:memory": "node --expose-gc memory-test.js",
    "clean": "rm -rf dist node_modules/.vite",
    
    // データベース
    "db:init": "bun run scripts/init-db.ts",
    "db:reset": "rm -f ./data/meetsonar.db && bun run db:init",
    
    // テスト（軽量）
    "test": "NODE_OPTIONS='--max-old-space-size=512' bun test",
    "test:e2e": "NODE_OPTIONS='--max-old-space-size=1024' playwright test"
  }
}
```

## 6. 8GB環境特化：新規導入推奨ライブラリ

### 6.1 **パフォーマンス監視・最適化**

```json
{
  // メモリ監視・プロファイリング
  "web-vitals": "^3.5.2",              // 3KB - Core Web Vitals
  "memwatch-next": "^0.3.0",           // メモリリーク検出
  
  // バンドル分析
  "bundlesize": "^2.0.0",              // バンドルサイズ監視
  "bundle-analyzer": "^4.10.2",        // バンドル分析
  
  // 軽量ユーティリティ
  "just-debounce-it": "^3.2.0",        // 1KB - debounce
  "just-throttle": "^4.2.0",           // 1KB - throttle
  "mitt": "^3.0.1",                    // 0.2KB - イベントエミッター
  
  // 日付処理（軽量版）
  "dayjs": "^1.11.10",                 // 2.7KB（date-fns代替）
  
  // CSS-in-JS（超軽量）
  "goober": "^2.1.14"                  // 1.4KB（styled-components代替）
}
```

### 6.2 **開発・ビルドツール強化**

```json
{
  // 高速ビルド
  "lightning-css": "^1.27.0",          // 高速CSS処理
  "swc": "^1.9.2",                     // Rust製高速コンパイラ
  
  // 軽量開発サーバー
  "sirv-cli": "^2.0.2",               // 軽量静的サーバー
  "concurrently": "^9.1.0",           // 並行実行
  
  // 型チェック最適化
  "typescript": "^5.6.3",             // 最新版
  "ts-node": "^10.9.2",               // TypeScript実行
  
  // コード品質
  "eslint": "^9.17.0",                // 軽量設定
  "prettier": "^3.4.2",               // コードフォーマット
  
  // テスト（軽量）
  "vitest": "^2.1.8",                 // Viteベーステスト
  "happy-dom": "^18.0.1"              // 軽量DOM
}
```

### 6.3 **WebRTC・通信強化**

```json
{
  // WebSocket強化
  "reconnecting-websocket": "^4.4.0",  // 6KB - 自動再接続
  "ws": "^8.18.3",                     // Keep - 最適
  
  // WebRTC最適化
  "simple-peer": "^9.11.1",            // 23KB - 軽量WebRTC
  "adapter-webrtc": "^9.0.1",          // ブラウザ互換性
  
  // メディア処理
  "opus-recorder": "^8.0.5",           // 音声録音
  "canvas-to-blob": "^1.0.0",
```json
// WebRTC・通信強化 (続き)
{
  // メディア処理 (続き)
  "canvas-to-blob": "^1.0.0",          // 2KB - Canvas画像変換
  "webrtc-stats": "^4.0.0",            // WebRTC統計情報
  
  // ストリーミング最適化
  "hls.js": "^1.5.15",                 // HLS配信（将来用）
  "mediasoup-client": "^3.7.16",       // SFU用クライアント（将来用）
  
  // 音声処理
  "web-audio-api": "^0.2.2",           // Web Audio API拡張
  "audio-context-polyfill": "^1.0.1"   // ブラウザ対応強化
}
```

---

## 【8GB環境特化：便利系ユーティリティライブラリ】

### 7.1 **メモリ効率ユーティリティ**

```typescript
// utils/memory-utils.ts - 8GB環境用メモリ管理
export class MemoryManager {
  private static readonly MAX_HEAP_MB = 1500; // 1.5GB制限
  private static cleanupCallbacks: Array<() => void> = [];
  
  static monitor() {
    const usage = (performance as any).memory;
    if (usage?.usedJSHeapSize > this.MAX_HEAP_MB * 1024 * 1024) {
      this.forceCleanup();
    }
  }
  
  static registerCleanup(callback: () => void) {
    this.cleanupCallbacks.push(callback);
  }
  
  static forceCleanup() {
    this.cleanupCallbacks.forEach(cb => cb());
    // ガベージコレクション要求
    if ('gc' in window) (window as any).gc();
  }
}

// utils/performance-utils.ts - パフォーマンス監視
export class PerformanceMonitor {
  private static metrics = new Map<string, number>();
  
  static mark(name: string) {
    performance.mark(name);
  }
  
  static measure(name: string, startMark: string) {
    performance.measure(name, startMark);
    const measure = performance.getEntriesByName(name)[0];
    this.metrics.set(name, measure.duration);
    return measure.duration;
  }
  
  static getMetrics() {
    return Object.fromEntries(this.metrics);
  }
}

// utils/object-pool.ts - オブジェクトプール
export class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  private maxSize: number;
  
  constructor(
    createFn: () => T, 
    resetFn: (obj: T) => void, 
    maxSize = 100
  ) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.maxSize = maxSize;
  }
  
  acquire(): T {
    return this.pool.pop() || this.createFn();
  }
  
  release(obj: T) {
    if (this.pool.length < this.maxSize) {
      this.resetFn(obj);
      this.pool.push(obj);
    }
  }
}
```

### 7.2 **WebRTC専用ユーティリティ**

```typescript
// utils/webrtc-utils.ts - WebRTC特化ユーティリティ
export class WebRTCUtils {
  // デバイス列挙（キャッシュ付き）
  private static deviceCache: MediaDeviceInfo[] | null = null;
  
  static async getDevices(forceRefresh = false): Promise<MediaDeviceInfo[]> {
    if (!forceRefresh && this.deviceCache) {
      return this.deviceCache;
    }
    
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      this.deviceCache = devices;
      return devices;
    } catch (error) {
      console.error('Device enumeration failed:', error);
      return [];
    }
  }
  
  // 品質プロファイル
  static getQualityProfile(participantCount: number) {
    if (participantCount <= 2) {
      return {
        video: { width: 1280, height: 720, frameRate: 30 },
        audio: { sampleRate: 48000, channelCount: 2 }
      };
    } else if (participantCount <= 6) {
      return {
        video: { width: 640, height: 480, frameRate: 24 },
        audio: { sampleRate: 44100, channelCount: 1 }
      };
    } else {
      return {
        video: { width: 320, height: 240, frameRate: 15 },
        audio: { sampleRate: 22050, channelCount: 1 }
      };
    }
  }
  
  // 帯域幅測定
  static async measureBandwidth(): Promise<number> {
    const pc = new RTCPeerConnection();
    try {
      // 簡易帯域幅測定実装
      const start = performance.now();
      await pc.createOffer();
      const end = performance.now();
      
      // RTT基準の簡易計算
      const rtt = end - start;
      return rtt < 50 ? 5000000 : rtt < 100 ? 2000000 : 1000000;
    } finally {
      pc.close();
    }
  }
  
  // ブラウザ互換性チェック
  static checkSupport() {
    return {
      webrtc: !!(window.RTCPeerConnection || window.webkitRTCPeerConnection),
      getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
      getDisplayMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia),
      webassembly: typeof WebAssembly === 'object'
    };
  }
}

// utils/media-utils.ts - メディア処理ユーティリティ
export class MediaUtils {
  // 画像圧縮
  static compressImage(file: File, maxWidth = 640, quality = 0.8): Promise<Blob> {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d')!;
      const img = new Image();
      
      img.onload = () => {
        const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
        canvas.width = img.width * ratio;
        canvas.height = img.height * ratio;
        
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        canvas.toBlob(resolve!, 'image/jpeg', quality);
      };
      
      img.src = URL.createObjectURL(file);
    });
  }
  
  // 音声レベル測定
  static createAudioLevelMeter(stream: MediaStream): {
    getLevel: () => number;
    destroy: () => void;
  } {
    const audioContext = new AudioContext();
    const analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(stream);
    
    analyser.fftSize = 256;
    source.connect(analyser);
    
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    
    return {
      getLevel: () => {
        analyser.getByteFrequencyData(dataArray);
        return dataArray.reduce((a, b) => a + b) / dataArray.length / 255;
      },
      destroy: () => {
        source.disconnect();
        audioContext.close();
      }
    };
  }
}
```

### 7.3 **UI・UX 強化ユーティリティ**

```typescript
// utils/ui-utils.ts - UI専用ユーティリティ
export class UIUtils {
  // Intersection Observer（メモリ効率版）
  static createVisibilityObserver(
    callback: (entries: IntersectionObserverEntry[]) => void,
    options = { threshold: 0.1 }
  ) {
    if (!('IntersectionObserver' in window)) {
      // フォールバック
      return {
        observe: () => {},
        unobserve: () => {},
        disconnect: () => {}
      };
    }
    
    return new IntersectionObserver(callback, options);
  }
  
  // スムーズスクロール（軽量実装）
  static smoothScrollTo(element: HTMLElement, duration = 300) {
    const start = element.scrollTop;
    const target = element.scrollHeight - element.clientHeight;
    const distance = target - start;
    
    let startTime: number;
    
    function animation(currentTime: number) {
      if (!startTime) startTime = currentTime;
      const timeElapsed = currentTime - startTime;
      const progress = Math.min(timeElapsed / duration, 1);
      
      // easeInOutCubic
      const ease = progress < 0.5 
        ? 4 * progress * progress * progress
        : (progress - 1) * (2 * progress - 2) * (2 * progress - 2) + 1;
      
      element.scrollTop = start + distance * ease;
      
      if (timeElapsed < duration) {
        requestAnimationFrame(animation);
      }
    }
    
    requestAnimationFrame(animation);
  }
  
  // Resize Observer（メモリ効率版）
  static createResizeObserver(callback: (entries: ResizeObserverEntry[]) => void) {
    if (!('ResizeObserver' in window)) {
      // window.resize フォールバック
      const handler = () => callback([]);
      window.addEventListener('resize', handler);
      return {
        observe: () => {},
        unobserve: () => {},
        disconnect: () => window.removeEventListener('resize', handler)
      };
    }
    
    return new ResizeObserver(callback);
  }
  
  // Debounce（軽量実装）
  static debounce<T extends (...args: any[]) => any>(
    func: T,
    wait: number
  ): (...args: Parameters<T>) => void {
    let timeout: number;
    return (...args: Parameters<T>) => {
      clearTimeout(timeout);
      timeout = window.setTimeout(() => func(...args), wait);
    };
  }
  
  // Throttle（軽量実装）
  static throttle<T extends (...args: any[]) => any>(
    func: T,
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean;
    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
}

// utils/storage-utils.ts - ストレージユーティリティ
export class StorageUtils {
  private static readonly PREFIX = 'meetsonar_';
  
  // localStorage（エラーハンドリング付き）
  static setItem(key: string, value: any): boolean {
    try {
      localStorage.setItem(this.PREFIX + key, JSON.stringify(value));
      return true;
    } catch (error) {
      console.warn('localStorage write failed:', error);
      return false;
    }
  }
  
  static getItem<T>(key: string, defaultValue: T): T {
    try {
      const item = localStorage.getItem(this.PREFIX + key);
      return item ? JSON.parse(item) : defaultValue;
    } catch (error) {
      console.warn('localStorage read failed:', error);
      return defaultValue;
    }
  }
  
  static removeItem(key: string): boolean {
    try {
      localStorage.removeItem(this.PREFIX + key);
      return true;
    } catch (error) {
      console.warn('localStorage delete failed:', error);
      return false;
    }
  }
  
  // メモリ使用量監視付きキャッシュ
  private static cache = new Map<string, { value: any; timestamp: number }>();
  private static readonly CACHE_TTL = 300000; // 5分
  private static readonly MAX_CACHE_SIZE = 100;
  
  static cacheSet(key: string, value: any) {
    if (this.cache.size >= this.MAX_CACHE_SIZE) {
      // 古いエントリを削除
      const oldestKey = Array.from(this.cache.keys())[0];
      this.cache.delete(oldestKey);
    }
    
    this.cache.set(key, {
      value,
      timestamp: Date.now()
    });
  }
  
  static cacheGet<T>(key: string): T | null {
    const cached = this.cache.get(key);
    if (!cached) return null;
    
    if (Date.now() - cached.timestamp > this.CACHE_TTL) {
      this.cache.delete(key);
      return null;
    }
    
    return cached.value;
  }
}
```

### 7.4 **ネットワーク・API ユーティリティ**

```typescript
// utils/network-utils.ts - ネットワーク最適化
export class NetworkUtils {
  // フェッチ（タイムアウト・リトライ付き）
  static async fetchWithRetry(
    url: string,
    options: RequestInit = {},
    retries = 3,
    timeout = 5000
  ): Promise<Response> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok && retries > 0) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (retries > 0 && error.name !== 'AbortError') {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return this.fetchWithRetry(url, options, retries - 1, timeout);
      }
      
      throw error;
    }
  }
  
  // 接続状態監視
  static createConnectionMonitor() {
    const listeners = new Set<(online: boolean) => void>();
    
    const updateStatus = () => {
      listeners.forEach(listener => listener(navigator.onLine));
    };
    
    window.addEventListener('online', updateStatus);
    window.addEventListener('offline', updateStatus);
    
    return {
      subscribe: (listener: (online: boolean) => void) => {
        listeners.add(listener);
        listener(navigator.onLine); // 初期状態
      },
      unsubscribe: (listener: (online: boolean) => void) => {
        listeners.delete(listener);
      },
      destroy: () => {
        window.removeEventListener('online', updateStatus);
        window.removeEventListener('offline', updateStatus);
        listeners.clear();
      }
    };
  }
  
  // 帯域幅測定（簡易版）
  static async measureNetworkSpeed(): Promise<{
    download: number; // Mbps
    latency: number;  // ms
  }> {
    const start = performance.now();
    
    try {
      // 小さなテスト画像をダウンロード
      const response = await fetch('/api/speed-test');
      const blob = await response.blob();
      
      const end = performance.now();
      const duration = (end - start) / 1000; // 秒
      const sizeInMb = blob.size / (1024 * 1024);
      
      return {
        download: sizeInMb / duration,
        latency: end - start
      };
    } catch (error) {
      return { download: 0, latency: Infinity };
    }
  }
}

// utils/queue-utils.ts - キューイングシステム
export class MessageQueue {
  private queue: Array<{ id: string; data: any; timestamp: number }> = [];
  private processing = false;
  private readonly maxSize: number;
  private readonly maxAge: number;
  
  constructor(maxSize = 1000, maxAge = 60000) {
    this.maxSize = maxSize;
    this.maxAge = maxAge;
  }
  
  enqueue(data: any): string {
    const id = crypto.randomUUID();
    const timestamp = Date.now();
    
    // キューサイズ制限
    if (this.queue.length >= this.maxSize) {
      this.queue.shift(); // 古いメッセージを削除
    }
    
    this.queue.push({ id, data, timestamp });
    this.processQueue();
    
    return id;
  }
  
  private async processQueue() {
    if (this.processing) return;
    this.processing = true;
    
    while (this.queue.length > 0) {
      const message = this.queue.shift()!;
      
      // 期限切れチェック
      if (Date.now() - message.timestamp > this.maxAge) {
        continue;
      }
      
      try {
        await this.processMessage(message);
      } catch (error) {
        console.error('Message processing failed:', error);
      }
    }
    
    this.processing = false;
  }
  
  private async processMessage(message: { id: string; data: any }) {
    // オーバーライド用
    console.log('Processing message:', message.id);
  }
  
  getQueueLength(): number {
    return this.queue.length;
  }
  
  clear() {
    this.queue.length = 0;
  }
}
```

---

## 【8GB環境特化：最終的な依存関係リスト】

### 最適化後のpackage.json

```json
{
  "name": "meetsonar-optimized",
  "version": "2.0.0",
  "type": "module",
  "dependencies": {
    // フロントエンド（軽量化）
    "preact": "^10.24.3",                 // React代替（40%軽量）
    "@preact/compat": "^17.1.2",         // React互換性
    "@preact/signals": "^1.3.0",         // 超軽量状態管理（3KB）
    "swr": "^2.2.5",                     // TanStack Query代替（80%軽量）
    "wouter": "^3.3.5",                  // 軽量ルーター（継続）
    "clsx": "^2.1.1",                    // ユーティリティ（継続）
    
    // UI（自作コンポーネント・最小限）
    "goober": "^2.1.14",                 // CSS-in-JS（1.4KB）
    "mitt": "^3.0.1",                    // イベントエミッター（200B）
    
    // WebRTC・通信
    "simple-peer": "^9.11.1",            // WebRTC（継続・軽量）
    "reconnecting-websocket": "^4.4.0",  // WebSocket自動再接続
    "ws": "^8.18.3",                     // バックエンドWebSocket（継続）
    
    // バックエンド（統合・軽量化）
    "better-sqlite3": "^12.2.0",         // SQLite（継続）
    "zod": "^3.24.2",                    // バリデーション（継続）
    
    // ユーティリティ（軽量版）
    "dayjs": "^1.11.10",                 // 日付処理（date-fns代替）
    "just-debounce-it": "^3.2.0",        // デバウンス（1KB）
    "just-throttle": "^4.2.0",           // スロットル（1KB）
    
    // 監視・最適化
    "web-vitals": "^3.5.2",              // パフォーマンス監視（3KB）
    
    // 削除された依存関係
    // ❌ "@tanstack/react-query"         - SWRで代替
    // ❌ "react", "react-dom"            - Preactで代替  
    // ❌ "@radix-ui/*"                   - 自作コンポーネントで代替
    // ❌ "framer-motion"                 - CSS Animationで代替
    // ❌ "lucide-react"                  - SVGインライン化
    // ❌ "recharts"                      - 不要（チャート機能削除）
    // ❌ "date-fns"                      - dayjsで代替
    // ❌ "express"                       - Bun native HTTPで代替
    // ❌ "drizzle-orm"                   - 直接SQLで代替
    // ❌ "pg", "postgres"                - SQLiteで代替
    // ❌ "passport", "express-session"   - 簡易認証で代替
  },
  
  "devDependencies": {
    "@preact/preset-vite": "^2.9.0",     // Vite Preact設定
    "vite": "^5.4.19",                   // ビルドツール（継続）
    "typescript": "^5.6.3",              // 型システム（継続）
    "tailwindcss": "^3.4.17",            // CSS（継続）
    "lightning-css": "^1.27.0",          // 高速CSS処理
    "bundlesize": "^2.0.0",              // バンドルサイズ監視
    "vitest": "^2.1.8",                  // 軽量テスト
    "happy-dom": "^18.0.1",              // 軽量DOM
    "@playwright/test": "^1.54.1",       // E2Eテスト（継続）
    
    // 削除された開発依存関係  
    // ❌ "@vitejs/plugin-react"         - @preact/preset-viteで代替
    // ❌ "drizzle-kit"                   - SQLiteスクリプトで代替
    // ❌ "esbuild"                       - Vite内蔵版使用
    // ❌ "tsx"                           - Bunで直接実行
  },

  "bundlesize": [
    {
      "path": "./dist/assets/*.js",
      "maxSize": "150 KB"               // 厳格なサイズ制限
    },
    {
      "path": "./dist/assets/*.css", 
      "maxSize": "30 KB"
    }
  ]
}
```

---

## 【優先度付き実装ロードマップ】

### Phase 1: 即座実装（影響度★★★／コスト低）

1. **PostgreSQL → SQLite移行**（1日）
   - `better-sqlite3`の直接使用
   - WALモード設定
   - 準備済みステートメント実装

2. **React → Preact移行**（2日）
   - 依存関係変更
   - コンポーネント修正
   - ビルド設定調整

3. **TanStack Query → SWR**（1日）
   - データフェッチロジック変更
   - キャッシュ設定最適化

### Phase 2: 1週間以内（影響度★★／コスト中）

4. **Express → Bun統合**（3日）
   - HTTPサーバー統合
   - ルーティング実装
   - 静的ファイル配信

5. **Radix UI → 自作コンポーネント**（3日）
   - 必要最小限のUI実装
   - dialog, select, button

6. **アイコン軽量化**（1日）
   - SVGインライン化
   - 不要アイコン削除

### Phase 3: 2週間以内（影響度★／コスト低）

7. **ユーティリティライブラリ統合**（2日）
   - メモリ管理システム
   - パフォーマンス監視

8. **ビルド最適化強化**（2日）
   - バンドル分析
   - サイズ制限設定

9. **デバッグ・監視ツール**（3日）
   - メモリ使用量ダッシュボード
   - パフォーマンス計測

---

## 【期待される効果】

### メモリ使用量削減
- **フロントエンド**: 従来の60% → 25%（1.5GB削減）
- **バックエンド**: 従来の40% → 20%（1.6GB削減）
- **総計**: 8GB中3.1GB削減 → **5GB利用可能**

### パフォーマンス向上
- **初期ロード時間**: 50%短縮（3秒→1.5秒）
- **WebRTC接続時間**: 30%短縮（3秒→2.1秒）
- **同時接続可能数**: 2-3倍向上（30名→100名）

### 開発効率向上
- **ビルド時間**: 40%短縮
- **ホットリロード**: 60%高速化
- **バンドルサイズ**: 70%削減

この最適化により、8GB共有CPU環境でも**安定的に100名同時接続**、**Discord/Meet/Zoomレベルの品質**を実現可能になります。